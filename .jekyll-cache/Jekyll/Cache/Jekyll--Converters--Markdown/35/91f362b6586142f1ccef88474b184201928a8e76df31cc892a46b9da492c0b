I"±ç<p><a href="https://community.idera.com/database-tools/powershell/powertips/b/ebookv2/posts/chapter-7-conditions">Chapter 7. Conditions</a></p>

<p>Conditions are what you need to make scripts clever. Conditions can evaluate a situation and then take appropriate action. There are a number of condition constructs in the PowerShell language which that we will look at in this chapter.</p>

<p>In the second part, you‚Äôll employ conditions to execute PowerShell instructions only if a particular condition is actually met.</p>

<p><strong>Topics Covered:</strong></p>

<p>[TOC]</p>

<h2 id="creating-conditions">Creating Conditions</h2>

<p>A condition is really just a question that can be answered with yes (true) or no (false). The following PowerShell comparison operators allow you to compare values,</p>

<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Conventional</th>
      <th>Description</th>
      <th>Example</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-eq, -ceq, -ieq</td>
      <td>=</td>
      <td>equals</td>
      <td>10 -eq 15</td>
      <td>$false</td>
    </tr>
    <tr>
      <td>-ne, -cne, -ine</td>
      <td>&lt;&gt;</td>
      <td>not equal</td>
      <td>10 -ne 15</td>
      <td>$true</td>
    </tr>
    <tr>
      <td>-gt, -cgt, -igt</td>
      <td>&gt;</td>
      <td>greater than</td>
      <td>10 -gt 15</td>
      <td>$false</td>
    </tr>
    <tr>
      <td>-ge, -cge, -ige</td>
      <td>&gt;=</td>
      <td>greater than or equal to</td>
      <td>10 -ge 15</td>
      <td>$false</td>
    </tr>
    <tr>
      <td>-lt, -clt, -ilt</td>
      <td>&lt;</td>
      <td>less than</td>
      <td>10 -lt 15</td>
      <td>$true</td>
    </tr>
    <tr>
      <td>-le, -cle, -ile</td>
      <td>&lt;=</td>
      <td>less than or equal to</td>
      <td>10 -le 15</td>
      <td>$true</td>
    </tr>
    <tr>
      <td>-contains, -ccontains, -icontains</td>
      <td>¬†</td>
      <td>contains</td>
      <td>1,2,3 -contains 1</td>
      <td>$true</td>
    </tr>
    <tr>
      <td>-notcontains, -cnotcontains, -inotcontains</td>
      <td>¬†</td>
      <td>does not contain</td>
      <td>1,2,3 -notcontains 1</td>
      <td>$false</td>
    </tr>
  </tbody>
</table>

<p><strong>Table 7.1:</strong> Comparison operators</p>

<p>PowerShell doesn‚Äôt use traditional comparison operators that you may know from other programming languages. In particular, the ‚Äú=‚Äù operator is an assignment operator only in PowerShell, while ‚Äú&gt;‚Äù and ‚Äú&lt;‚Äù operators are used for redirection.</p>

<p>There are three variants of all comparison operators. The basic variant is case-insensitive so it does not distinguish between upper and lower case letters (if you compare text). To explicitly specify whether case should be taken into account, you can use variants that begin with ‚Äúc‚Äù (case-sensitive) or ‚Äúi‚Äù (case-insensitive).</p>

<h3 id="carrying-out-a-comparison">Carrying Out a Comparison</h3>

<p>To get familiar with comparison operators, you can play with them in the interactive PowerShell console! First, enter a value, then a comparison operator, and then the second value that you want to compare with the first. When you hit (enter)), PowerShell executes the comparison. The result is always <em>True</em> (condition is met) or <em>False</em> (condition not met).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4 -eq 10 
False
"secret" -ieq "SECRET"  
True
</code></pre></div></div>

<p>As long as you compare only numbers or only strings, comparisons are straight-forward:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>123 -lt 123.5 
True
</code></pre></div></div>

<p>However, you can also compare different data types. However, these results are not always as straight-forward as the previous one:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>12 -eq "Hello" 
False
12 -eq "000012" 
True
"12" -eq 12 
True
"12" -eq 012 
True
"012" -eq 012 
False
123 ‚Äìlt 123.4 
True
123 ‚Äìlt "123.4" 
False
123 ‚Äìlt "123.5" 
True
</code></pre></div></div>

<p>Are the results surprising? When you compare different data types, PowerShell will try to convert the data types into one common data type. It will always look at the data type to the left of the comparison operator and then try and convert the value to the right to this data type.</p>

<h3 id="reversing-comparisons">‚ÄúReversing‚Äù Comparisons</h3>

<p>With the logical operator <em>-not</em> you can reverse comparison results. It will expect an expression on the right side that is either true or <em>false</em>. Instead of -not, you can also use ‚Äú!‚Äù:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$a = 10 
$a -gt 5 
True
-not ($a -gt 5) 
False

# Shorthand: instead of -not "!" can also be used:
!($a -gt 5)
False
</code></pre></div></div>

<p>You should make good use of parentheses if you‚Äôre working with logical operators like <em>‚Äìnot</em>. Logical operators are always interested in the result of a comparison, but not in the comparison itself. That‚Äôs why the comparison should always be in parentheses.</p>

<h3 id="combining-comparisons">Combining Comparisons</h3>

<p>You can combine several comparisons with logical operators because every comparison returns either <em>True</em> or <em>False</em>. The following conditional statement would evaluate to true only if both comparisons evaluate to true:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>( ($age -ge 18) -and ($sex -eq "m") )
</code></pre></div></div>

<p>You should put separate comparisons in parentheses because you only want to link the results of these comparisons and certainly not the comparisons themselves.</p>

<table>
  <thead>
    <tr>
      <th>Operator</th>
      <th>Description</th>
      <th>Left Value</th>
      <th>Right Value</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-and</td>
      <td>Both conditions must be met</td>
      <td>True False False True</td>
      <td>False True False True</td>
      <td>False False False True</td>
    </tr>
    <tr>
      <td>-or</td>
      <td>At least one of the two conditions must be met</td>
      <td>True False False True</td>
      <td>False True False True</td>
      <td>True True False True</td>
    </tr>
    <tr>
      <td>-xor</td>
      <td>One or the other condition must be met, but not both</td>
      <td>True False False True</td>
      <td>True False True False</td>
      <td>False False True True</td>
    </tr>
    <tr>
      <td>-not</td>
      <td>Reverses the result</td>
      <td>(not applicable)</td>
      <td>True False</td>
      <td>False True</td>
    </tr>
  </tbody>
</table>

<p><strong>Table 7.2:</strong> Logical operators</p>

<h3 id="comparisons-with-arrays-and-collections">Comparisons with Arrays and Collections</h3>

<p>Up to now, you‚Äôve only used the comparison operators in Table 7.1 to compare single values. In <a href="http://powershell.com/cs/blogs/ebookv2/archive/2012/02/07/chapter-4-arrays-and-hashtables.aspx">Chapter 4</a>, you‚Äôve already become familiar with arrays. How do comparison operators work on arrays? Which element of an array is used in the comparison? The simple answer is all elements!</p>

<p>In this case, comparison operators work pretty much as a filter and return a new array that only contains the elements that matched the comparison.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1,2,3,4,3,2,1 -eq 3 
3
3
</code></pre></div></div>

<p>If you‚Äôd like to see only the elements of an array that don‚Äôt match the comparison value, you can use <em>-ne</em> (<em>not equal</em>) operator:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1,2,3,4,3,2,1 -ne 3 
1
2
4
2
1
</code></pre></div></div>

<h4 id="verifying-whether-an-array-contains-a-particular-element">Verifying Whether an Array Contains a Particular Element</h4>

<p>But how would you find out whether an array contains a particular element? As you have seen, -eq provides matching array elements only. <em>-contains</em> and <em>-notcontains</em>. verify whether a certain value exists in an array.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># -eq returns only those elements matching the criterion:
1,2,3 ‚Äìeq 5 

# -contains answers the question of whether the sought element is included in the array:
1,2,3 -contains 5 
False
1,2,3 -notcontains 5 
True
</code></pre></div></div>

<h2 id="where-object">Where-Object</h2>

<p>In the pipeline, the results of a command are handed over to the next one and the <em>Where-Object</em> cmdlet will work like a filter, allowing only those objects to pass the pipeline that meet a certain condition. To make this work, you can specify your condition to <em>Where-Object</em>.</p>

<h3 id="filtering-results-in-the-pipeline">Filtering Results in the Pipeline</h3>

<p>The cmdlet <em>Get-Process</em> returns all running processes. If you would like to find out currently running instances of Notepad, you will need to set up the appropriate comparison term. You will first need to know the names of all the properties found in process objects. Here is one way of listing them:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Process | Select-Object -first 1 *
__NounName                 : process
Name                       : agrsmsvc
Handles                    : 36
VM                         : 21884928
WS                         : 57344
PM                         : 716800
NPM                        : 1768
Path                       :
Company                    :
CPU                        :
FileVersion                :
ProductVersion             :
Description                :
Product                    :
Id                         : 1316
PriorityClass              :
HandleCount                : 36
WorkingSet                 : 57344
PagedMemorySize            : 716800
PrivateMemorySize          : 716800
VirtualMemorySize          : 21884928
TotalProcessorTime         :
BasePriority               : 8
ExitCode                   :
HasExited                  :
ExitTime                   :
Handle                     :
MachineName                : .
MainWindowHandle           : 0
MainWindowTitle            :
MainModule                 :
MaxWorkingSet              :
MinWorkingSet              :
Modules                    :
NonpagedSystemMemorySize   : 1768
NonpagedSystemMemorySize64 : 1768
PagedMemorySize64          : 716800
PagedSystemMemorySize      : 24860
PagedSystemMemorySize64    : 24860
PeakPagedMemorySize        : 716800
PeakPagedMemorySize64      : 716800
PeakWorkingSet             : 2387968
PeakWorkingSet64           : 2387968
PeakVirtualMemorySize      : 21884928
PeakVirtualMemorySize64    : 21884928
PriorityBoostEnabled       :
PrivateMemorySize64        : 716800
PrivilegedProcessorTime    :
ProcessName                : agrsmsvc
ProcessorAffinity          :
Responding                 : True
SessionId                  : 0
StartInfo                  : System.Diagnostics.ProcessStartInfo
StartTime                  :
SynchronizingObject        :
Threads                    : {1964, 1000}
UserProcessorTime          :
VirtualMemorySize64        : 21884928
EnableRaisingEvents        : False
StandardInput              :
StandardOutput             :
StandardError              :
WorkingSet64               : 57344
Site                       :
Container                  :
</code></pre></div></div>

<h3 id="putting-together-a-condition">Putting Together a Condition</h3>

<p>As you can see from the previous output, the name of a process can be found in the <em>Name</em> property. If you‚Äôre just looking for the processes of the Notepad, your condition is: <em>name -eq ‚Äònotepad</em>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Process | Where-Object { $_.name -eq 'notepad' }
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
     68       4     1636       8744    62     0,14   7732 notepad
     68       4     1632       8764    62     0,05   7812 notepad
</code></pre></div></div>

<p>Here are two things to note: if the call does not return anything at all, then there are probably no Notepad processes running. Before you make the effort and use Where-Object to filter results, you should make sure the initial cmdlet has no parameter to filter the information you want right away. For example, Get-Process already supports a parameter called -name, which will return only the processes you specify:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Process -name notepad
Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName
-------  ------    -----      ----- -----   ------     -- -----------
     68       4     1636       8744    62     0,14   7732 notepad
     68       4     1632       8764    62     0,05   7812 notepad
</code></pre></div></div>

<p>The only difference with the latter approach: if no Notepad process is running, Get-Process throws an exception, telling you that there is no such process. If you don‚Äôt like that, you can always add the parameter -ErrorAction SilentlyContinue, which will work for all cmdlets and hide all error messages.</p>

<p>When you revisit your Where-Object line, you‚Äôll see that your condition is specified in curly brackets after the cmdlet. The $_ variable contains the current pipeline object. While sometimes the initial cmdlet is able to do the filtering all by itself (like in the previous example using -name), Where-Object is much more flexible because it can filter on any piece of information found in an object.</p>

<p>You can use the next one-liner to retrieve all processes whose company name begins with ‚ÄúMicro‚Äù and output name, description, and company name:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Process | Where-Object { $_.company -like 'micro*' } | Select-Object name, description, company
Name                               Description                       Company
----                               -----------                       -------
conime                             Console IME                       Microsoft Corporation
dwm                                Desktopwindow-Manager             Microsoft Corporation
ehmsas                             Media Center Media Status Aggr... Microsoft Corporation
ehtray                             Media Center Tray Applet          Microsoft Corporation
EXCEL                              Microsoft Office Excel            Microsoft Corporation
explorer                           Windows-Explorer                  Microsoft Corporation
GrooveMonitor                      GrooveMonitor Utility             Microsoft Corporation
ieuser                             Internet Explorer                 Microsoft Corporation
iexplore                           Internet Explorer                 Microsoft Corporation
msnmsgr                            Messenger                         Microsoft Corporation
notepad                            Editor                            Microsoft Corporation
notepad                            Editor                            Microsoft Corporation
sidebar                            Windows-Sidebar                   Microsoft Corporation
taskeng                            Task Scheduler Engine             Microsoft Corporation
WINWORD                            Microsoft Office Word             Microsoft Corporation
wmpnscfg                           Windows Media Player Network S... Microsoft Corporation
wpcumi                             Windows Parental Control Notif... Microsoft Corporation
</code></pre></div></div>

<p>Since you will often need conditions in a pipeline, there is an alias for <em>Where-Object</em>: ‚Äú?‚Äù. So, instead of <em>Where-Object</em>, you can also use ‚Äú?‚Äô‚Äù. However, it does make your code a bit unreadable:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># The two following instructions return the same result: all running services
Get-Service | Foreach-Object {$_.Status -eq 'Running' }
Get-Service | ? {$_.Status -eq 'Running' }
</code></pre></div></div>

<h2 id="if-elseif-else">If-ElseIf-Else</h2>

<p><em>Where-object</em> works great in the pipeline, but it is inappropriate if you want to make longer code segments dependent on meeting a condition. Here, the <em>If..ElseIf..Else</em> statement works much better. In the simplest case, the statement will look like this:</p>

<p>test</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Help on PowerShell's if statements
Clear-Host
$File = Get-Help about_if
If ($File -Match "The if Statement") {
"We have the correct help file"
}
</code></pre></div></div>

<p>test</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If (condition) {# If the condition applies, this code will be executed}
</code></pre></div></div>

<p>The condition must be enclosed in parentheses and follow the keyword <em>If</em>. If the condition is met, the code in the curly brackets after it will be executed, otherwise, it will not. Try it out:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If ($a -gt 10) { "$a is larger than 10" } 
</code></pre></div></div>

<p>It‚Äôs likely, though, that you won‚Äôt (yet) see a result. The condition was not met, and so the code in the curly brackets wasn‚Äôt executed. To get an answer, you can make sure that the condition is met:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$a = 11 
if ($a -gt 10) { "$a is larger than 10" } 
11 is larger than 10
</code></pre></div></div>

<p>Now, the comparison is true, and the <em>If</em> statement ensures that the code in the curly brackets will return a result. As it is, that clearly shows that the simplest <em>If</em> statement usually doesn‚Äôt suffice in itself, because you would like to <em>always</em> get a result, even when the condition isn‚Äôt met. You can expand the <em>If</em> statement with <em>Else</em> to accomplish that:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ($a -gt 10) 
{
  "$a is larger than 10"
} 
else
{
  "$a is less than or equal to 10"
}
</code></pre></div></div>

<p>Now, the code in the curly brackets after <em>If</em> is executed if the condition is met. However, if the preceding condition isn‚Äôt true, the code in the curly brackets after <em>Else will be executed</em>. If you have several conditions, you may insert as many <em>ElseIf</em> blocks between <em>If</em> and <em>Else</em> as you like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ($a -gt 10) 
{
  "$a is larger than 10"
} 
elseif ($a -eq 10) 
{
  "$a is exactly 10"
} 
else 
{
  "$a is less than 10"
}
</code></pre></div></div>

<p>The <em>If</em> statement here will always execute the code in the curly brackets after the condition that is met. The code after <em>Else</em> will be executed when none of the preceding conditions are true. What happens if several conditions are true? Then the code after the first applicable condition will be executed and all other applicable conditions will be ignored.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ($a -gt 10) 
{
  "$a is larger than 10"
} 
elseif ($a -eq 10) 
{
  "$a is exactly 10"
} 
elseif ($a ‚Äìge 10) 
{
  "$a is larger than or equal to 10"
} 
else 
{
  "$a is smaller than 10"
}
</code></pre></div></div>

<p>The fact is that the <em>If</em> statement doesn‚Äôt care at all about the condition that you state. All that the <em>If</em> statement evaluates is <em>$true</em> or <em>$false</em>. If condition evaluates <em>$true</em>, the code in the curly brackets after it will be executed, otherwise, it will not. Conditions are only a way to return one of the requested values <em>$true</em> or <em>$false</em>. But the value could come from another function or from a variable:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Returns True from 14:00 on, otherwise False:
function isAfternoon { (get-date).Hour -gt 13 }
isAfternoon
True

# Result of the function determines which code the If statement executes:
if (isAfternoon) { "Time for break!" } else { "It‚Äôs still early." }
Time for break!
</code></pre></div></div>

<p>This example shows that the condition after <em>If</em> must always be in parentheses, but it can also come from any source as long as it is <em>$true</em> or <em>$false</em>. In addition, you can also write the <em>If</em> statement in a single line. If you‚Äôd like to execute more than one command in the curly brackets without having to use new lines, then you should separate the commands with a semi-colon ‚Äú;‚Äù.</p>

<h2 id="switch">Switch</h2>

<p>If you‚Äôd like to test a value against many comparison values, the <em>If</em> statement can quickly become unreadable. The <em>Switch</em> code is much cleaner:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Test a value against several comparison values (with If statement):
$value = 1
if ($value -eq 1)
{ 
  " Number 1"
}
elseif ($value -eq 2)
{ 
  " Number 2"
}
elseif ($value -eq 3)
{ 
  " Number 3"
}
Number 1

# Test a value against several comparison values (with Switch statement):
$value = 1
switch ($value)
{
  1  { "Number 1" }
  2  { "Number 2" }
  3  { "Number 3" }
}
Number 1
</code></pre></div></div>

<p>This is how you can use the <em>Switch statement</em>: the value to switch on is in the parentheses after the <em>Switch keyword</em>. That value is matched with each of the conditions on a case-by-case basis. If a match is found, the action associated with that condition is then performed. You can use the default comparison operator, the <em>‚Äìeq</em> operator, to verify equality.</p>

<h3 id="testing-range-of-values">Testing Range of Values</h3>

<p>The default comparison operator in a switch statement is <em>-eq</em>, but you can also compare a value with other comparison statements. You can create your own condition and put it in curly brackets. The condition must then result in either <em>true</em> or <em>false</em>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$value = 8
switch ($value)
{
  # Instead of a standard value, a code block is used that results in True for numbers smaller than 5:
  {$_ -le 5}  { "Number from 1to 5" }

  # A value is used here; Switch checks whether this value matches $value:
  6  { "Number 6" }

  # Complex conditions areallowed as they are here, where ‚Äìand is used to combine two comparisons:
  {(($_ -gt 6) -and ($_ -le 10))}  { "Number from 7 to 10" }
}
Number from 7 to 10
</code></pre></div></div>

<ul>
  <li>The code block <em>{$_ -le 5}</em> includes all numbers less than or equal to 5.</li>
  <li>The code block <em>{(($_ -gt 6) -and ($_ -le 10))}</em> combines two conditions and results in true if the number is either larger than 6 or less than-equal to 10. Consequently, you can combine any PowerShell statements in the code block and also use the logical operators listed in Table 7.2.</li>
</ul>

<p>Here, you can use the initial value stored in <em>$_</em> for your conditions, but because <em>$_</em> is generally available anywhere in the Switch block, you could just as well have put it to work in the result code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$value = 8
switch ($value)
{
  # The initial value (here it is in $value) is available in the variable $_:
  {$_ -le 5}  { "$_ is a number from 1 to 5" }
  6  { "Number 6" }
  {(($_ -gt 6) -and ($_ -le 10))}  { "$_ is a number from 7 to 10" }
}
8 is a number from 7 to 10
</code></pre></div></div>

<h3 id="no-applicable-condition">No Applicable Condition</h3>

<p>In contrast to <em>If</em>, the <em>Switch</em> clause will execute all code for all conditions that are met. So, if there are two conditions that are both met, <em>Switch</em> will execute them both whereas <em>If</em> had only executed the first matching condition code. To change the Switch default behavior and make it execute only the first matching code, you should use the statement <em>continue</em> inside of a code block.</p>

<p>If no condition is met, the <em>If</em> clause will provide the <em>Else</em> statement, which serves as a catch-all. Likewise, <em>Switch</em> has a similar catch-all called <em>default</em>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$value = 50
switch ($value)
{
  {$_ -le 5}  { "$_is a number from 1 to 5" }
  6  { "Number 6" }
  {(($_ -gt 6) -and ($_ -le 10))}  { "$_ is a number from 7 to 10" }
  # The code after the next statement will be executed if no other condition has been met:
  default {"$_ is a number outside the range from 1 to 10" }
}
50 is a number outside the range from 1 to 10
</code></pre></div></div>

<h3 id="several-applicable-conditions">Several Applicable Conditions</h3>

<p>If more than one condition applies, then <em>Switch</em> will work differently from <em>If</em>. For <em>If</em>, only the first applicable condition was executed. For <em>Switch</em>, all applicable conditions are executed:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$value = 50
switch ($value)
{
  50  { "the number 50" }
  {$_ -gt 10}  {"larger than 10"}
  {$_ -is [int]}  {"Integer number"}
}
The Number 50
Larger than 10
Integer number
</code></pre></div></div>

<p>Consequently, all applicable conditions will ensure that the following code is executed. So in some circumstances, you may get more than one result.</p>

<p>Try out that example, but assign 50.0 to $value. In this case, you‚Äôll get just two results instead of three. Do you know why? That‚Äôs right: the third condition is no longer fulfilled because the number in <em>$value</em> is no longer an integer number. However, the other two conditions continue to remain fulfilled.</p>

<p>If you‚Äôd like to receive only one result, you can add the continue or break statement to the code.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$value = 50
switch ($value)
{
  50  { "the number 50"; break }
  {$_ -gt 10}  {"larger than 10"; break}
  {$_ -is [int]}  {"Integer number"; break}
}
The number 50
</code></pre></div></div>

<p>The keyword <em>break</em> tells PowerShell to leave the Switch construct. In conditions, <em>break</em> and <em>continue</em> are interchangeable. In loops, they work differently. While <em>breaks</em> exits a loop immediately, <em>continue</em> would only exit the current iteration.</p>

<h3 id="using-string-comparisons">Using String Comparisons</h3>

<p>The previous examples have compared numbers. You could also naturally compare strings since you now know that <em>Switch</em> uses only the normal <em>‚Äìeq</em> comparison operator behind the scenes and that their string comparisons are also permitted.. The following code could be the basic structure of a command evaluation. As such, a different action will be performed, depending on the specified command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$action = "sAVe"
switch ($action)
{
  "save"  { "I save..." }
  "open"  { "I open..." }
  "print"  { "I print..." }
  Default  { "Unknown command" }
}
I save...
</code></pre></div></div>

<h4 id="case-sensitivity">Case Sensitivity</h4>

<p>Since the <em>‚Äìeq</em> comparison operator doesn‚Äôt distinguish between lower and upper case, case sensitivity doesn‚Äôt play a role in comparisons. If you want to distinguish between them, you can use the <em>‚Äìcase</em> option. Working behind the scenes, it will replace the <em>‚Äìeq</em> comparison operator with <em>‚Äìceq</em>, after which case sensitivity will suddenly become crucial:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$action = "sAVe"
switch -case ($action)
{
  "save"  { "I save..." }
  "open"  { "I open..." }
  "print"  { "I print..." }
  Default  { "Unknown command" }
}
Unknown command
</code></pre></div></div>

<h4 id="wildcard-characters">Wildcard Characters</h4>

<p>In fact, you can also exchange a standard comparison operator for <em>‚Äìlike</em> and <em>‚Äìmatch</em> operators and then carry out wildcard comparisons. Using the <em>‚Äìwildcard</em> option, you can activate the <em>-like</em> operator, which is conversant, among others, with the ‚Äú*‚Äù wildcard character:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$text = "IP address: 10.10.10.10"
switch -wildcard ($text)
{
  "IP*"  { "The text begins with IP: $_" }
  "*.*.*.*"  { "The text contains an IP address string pattern: $_" }
  "*dress*"  { "The text contains the string 'dress' in arbitrary locations: $_" }
}
The text begins with IP: IP address: 10.10.10.10 
The text contains an IP address string pattern: IP address: 10.10.10.10
The text contains the string 'dress' in arbitrary locations: IP address: 10.10.10.10
</code></pre></div></div>

<h4 id="regular-expressions">Regular Expressions</h4>

<p>Simple wildcard characters ca not always be used for recognizing patterns. Regular expressions are much more efficient. But they assume much more basic knowledge, which is why you should take a peek ahead at <a href="http://powershell.com/cs/blogs/ebookv2/archive/2012/03/06/chapter-13-text-and-regular-expressions.aspx">Chapter 13</a>, discussion of regular expression in greater detail.</p>

<p>With the <em>-regex</em> option, you can ensure that <em>Switch</em> uses the <em>‚Äìmatch</em> comparison operator instead of <em>‚Äìeq</em>, and thus employs regular expressions. Using regular expressions, you can identify a pattern much more precisely than by using simple wildcard characters. But that‚Äôs not all!. As in the case with the <em>‚Äìmatch</em> operator, you will usually get back the text that matches the pattern in the <em>$matches</em> variable. This way, you can even parse information out of the text:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$text = "IP address: 10.10.10.10"
switch -regex ($text)
{
  "^IP"  { "The text begins with IP: $($matches[0])" }
  "\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"  { "The text contains an IP address string pattern: $($matches[0])" }
  "\b.*?dress.*?\b"  { " The text contains the string 'dress' in arbitrary locations: $($matches[0])" }
}
The text begins with IP: IP
The text contains an IP address string pattern: 10.10.10.10
The text contains the string 'dress' in arbitrary locations: IP address
</code></pre></div></div>

<p>The result of the ‚Äìmatch comparison with the regular expression is returned in <em>$matches</em>, a hash table with each result, because regular expressions can, depending on their form, return several results. In this example, only the first result you got by using <em>$matches[0]</em> should interest you.. The entire expression is embedded in <em>$(‚Ä¶)</em> to ensure that this result appears in the output text.</p>

<h3 id="processing-several-values-simultaneously">Processing Several Values Simultaneously</h3>

<p>Until now, you have always passed just one value for evaluation to <em>Switch</em>. But <em>Switch</em> can also process several values at the same time. To do so, you can pass to <em>Switch</em> the values in an array or a collection. In the following example, <em>Switch</em> is passed an array containing five elements. <em>Switch</em> will automatically take all the elements, one at a time, from the array and compare each of them, one by one:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$array = 1..5
switch ($array)
{
  {$_ % 2} { "$_ is uneven."}
  Default { "$_ is even."}
}
1 is uneven.
2 is even.
3 is uneven.
4 is even.
5 is uneven.
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>There you have it: <em>Switch</em> will accept not only single values, but also entire arrays and collections. As such, <em>Switch</em> would be an ideal candidate for evaluating results on the PowerShell pipeline because the pipeline character (‚Äú</td>
      <td>‚Äù) is used to forward results as arrays or collections from one command to the next.</td>
    </tr>
  </tbody>
</table>

<p>The next line queries <em>Get-Process</em> for all running processes and then pipes the result to a script block (<em>&amp; {‚Ä¶}</em>). In the script block, <em>Switch</em> will evaluate the result of the pipeline, which is available in <em>$input</em>. If the <em>WS</em> property of a process is larger than one megabyte, this process is output. <em>Switch</em> will then filter all of the processes whose WS property is less than or equal to one megabyte:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Process | &amp; { Switch($input) { {$_.WS -gt 1MB} { $_ }}}
</code></pre></div></div>

<p>However, this line is extremely hard to read and seems complicated. You can formulate the condition in a much clearer way by using <em>Where-Object</em>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get-Process | Where-Object { $_.WS -gt 1MB }
</code></pre></div></div>

<p>This variant also works more quickly because <em>Switch</em> had to wait until the pipeline has collected the entire results of the preceding command in <em>$input</em>. In <em>Where-Object</em>, it processes the results of the preceding command precisely when the results are ready. This difference is especially striking for elaborate commands:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Switch returns all files beginning with "a":
Dir | &amp; { switch($Input) { {$_.name.StartsWith("a")} { $_ } }}

# But it doesn't do so until Dir has retrieved all data, and that can take a long time:
Dir -Recurse | &amp; { switch($Input) { {$_.name.StartsWith("a")} { $_ } }}

# Where-Object processes the incoming results immediately:
Dir -recurse | Where-Object { $_.name.StartsWith("a") }

# The alias of Where-Object ("?") works exactly the same way:
Dir -recurse | ? { $_.name.StartsWith("a") }
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<p>Intelligent decisions are based on conditions, which in their simplest form can be reduced to plain <em>Yes</em> or <em>No</em> answers. Using the comparison operators listed in Table 7.1, you can formulate such conditions and even combine these with the logical operators listed in Table 7.2 to form complex queries.</p>

<p>The simple <em>Yes/No</em> answers of your conditions will determine whether particular PowerShell instructions can carried out or not. In their simplest form, you can use the Where-Object cmdlet in the pipeline. It functions there like a filter, allowing only those results through the pipeline that correspond to your condition.</p>

<p>If you would like more control, or would like to execute larger code segments independently of conditions, you can use the <em>If</em> statement, which evaluates as many different conditions as you wish and, depending on the result, will then execute the allocated code. This is the typical ‚ÄúIf-Then‚Äù scenario: <em>if</em> certain conditions are met, <em>then</em> certain code segments will be executed.</p>

<p>An alternative to the <em>If</em> statement is the <em>Switch</em> statement. Using it, you can compare a fixed initial value with various possibilities. <em>Switch</em> is the right choice when you want to check a particular variable against many different possible values.</p>
:ET